import axios from "axios";
import dbConnect from "../../../../lib/mongoose";
import blackboxChat from "../../../../models/BlackboxChat";
import crypto from "crypto";
export default async function handler(req, res) {
  const {
    prompt = "Halo",
      web = "false",
      image = "false",
      agent = "false",
      name,
      id,
      continue: continueConv = "false"
  } = req.method === "GET" ? req.query : req.body;
  await dbConnect();
  let previousMessages = [];
  if (continueConv === "true") {
    previousMessages = await blackboxChat.find();
  }
  const generateId = () => crypto.randomBytes(16).toString("hex");
  const requestData = {
    messages: [...previousMessages.map(msg => ({
      id: msg._id.toString(),
      content: msg.content,
      role: msg.role
    })), {
      id: generateId(),
      content: prompt,
      role: "user"
    }],
    id: generateId(),
    previewToken: null,
    userId: null,
    codeModelMode: true,
    agentMode: agent === "true" && name && id ? {
      name: name,
      id: id
    } : {},
    trendingAgentMode: {},
    isMicMode: false,
    userSystemPrompt: null,
    maxTokens: 1024,
    playgroundTopP: null,
    playgroundTemperature: null,
    isChromeExt: false,
    githubToken: "",
    clickedAnswer2: false,
    clickedAnswer3: false,
    clickedForceWebSearch: false,
    visitFromDelta: false,
    mobileClient: false,
    userSelectedModel: null,
    validated: "00f37b34-a166-4efb-bce5-1312d87f2f94",
    imageGenerationMode: image === "true",
    webSearchModePrompt: web === "true",
    deepSearchMode: false,
    domains: null
  };
  try {
    const url = "https://api.blackbox.ai/api/chat";
    const headers = {
      "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
      accept: "*/*",
      "accept-language": "en-US,en;q=0.5",
      "accept-encoding": "gzip, deflate, br",
      referer: "https://www.blackbox.ai/",
      "content-type": "application/json",
      origin: "https://www.blackbox.ai",
      dnt: "1",
      "sec-gpc": "1",
      "alt-used": "www.blackbox.ai",
      connection: "keep-alive"
    };
    const blackboxResponse = await axios.post(url, requestData, {
      headers: headers
    });
    let cleanedData = blackboxResponse.data.replace(/Generated by BLACKBOX\.AI,.*?blackbox\.ai\n\n/g, "") || null;
    if (image === "true") {
      const imageMatch = cleanedData?.match(/\((https?:\/\/[^\)]+)\)/);
      if (imageMatch && imageMatch[1]) {
        cleanedData = imageMatch[1];
      }
    }
    const newChat = await blackboxChat.findOneAndUpdate({
      content: cleanedData,
      role: "assistant"
    }, {
      content: cleanedData,
      role: "assistant"
    }, {
      upsert: true,
      new: true
    });
    const userChat = await blackboxChat.findOneAndUpdate({
      content: prompt,
      role: "user"
    }, {
      content: prompt,
      role: "user"
    }, {
      upsert: true,
      new: true
    });
    if (continueConv === "true") {
      previousMessages.push({
        id: userChat._id.toString(),
        content: prompt,
        role: "user"
      });
      previousMessages.push({
        id: newChat._id.toString(),
        content: cleanedData,
        role: "assistant"
      });
      const continuedRequestData = {
        messages: previousMessages.map(msg => ({
          id: msg.id,
          content: msg.content,
          role: msg.role
        })),
        ...requestData
      };
      const continuedBlackboxResponse = await axios.post(url, continuedRequestData, {
        headers: headers
      });
      cleanedData = continuedBlackboxResponse.data.replace(/Generated by BLACKBOX\.AI,.*?blackbox\.ai\n\n/g, "") || null;
      if (image === "true") {
        const imageMatch = cleanedData?.match(/\((https?:\/\/[^\)]+)\)/);
        if (imageMatch && imageMatch[1]) {
          cleanedData = imageMatch[1];
        }
      }
      res.status(200).json({
        result: cleanedData
      });
    } else {
      res.status(200).json({
        result: cleanedData
      });
    }
  } catch (error) {
    res.status(500).json({
      error: "Terjadi kesalahan",
      details: error.message
    });
  }
}